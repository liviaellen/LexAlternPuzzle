<!DOCTYPE html>
<html>

<head>
    <style>
        /* Style the tab */
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
        }

        /* Style the buttons that are used to open the tab content */
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
        }

        /* Change background color of buttons on hover */
        .tab button:hover {
            background-color: #ddd;
        }

        /* Create an active/current tablink class */
        .tab button.active {
            background-color: #ccc;
        }

        /* Style the tab content */
        .tabcontent {
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }

        /*
         img.scaled {
         width: 100%;
         } */
        .center {
            margin-left: auto;
            margin-right: auto;
        }

        figure {
            text-align: center;
            font-style: italic;
            font-size: smaller;
            text-indent: 0;
        }
    </style>
    <meta charset="UTF-8">
    <title>CelljigsawJS</title>
    <script type="text/javascript" src="imagetracer.js"></script>
    <script type="text/javascript" src="flatten.js"></script>
    <script type="text/javascript">
        const lut = [false, true, true, true, true, false, true, true, true, true, false, true, false, false,
            false, true, true, false, false, false, true, false, true, true, false, false, false, false,
            false, false, false, true, true, false, false, false, false, false, false, false, true, true,
            false, true, false, false, false, true, false, false, false, false, false, false, false, false,
            false, false, false, false, false, false, false, true, true, false, false, false, false, false,
            false, false, false, false, false, false, false, false, false, false, false, false, false, false,
            false, false, false, false, false, false, false, false, false, false, false, false, true, false,
            false, false, false, false, false, false, true, true, false, true, false, false, false, true,
            false, false, false, false, false, false, false, false, false, false, false, false, false, false,
            false, false, true, false, false, false, false, false, false, false, false, false, false, false,
            false, false, false, false, true, false, false, false, true, false, true, true, false, false, false,
            false, false, false, false, true, false, false, false, false, false, false, false, false, false, false,
            false, false, false, false, false, false, false, false, false, false, false, false, false, false, false,
            false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false,
            false, false, false, false, false, false, false, true, false, false, false, true, false, true, true, false,
            false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, true,
            true, false, true, false, false, false, true, true, false, false, false, true, false, true, true, true, true,
            false, false, true, true, false, false];
        var xmldoc = null;
        var timerID;
        var autogrowth = false;
        var growthstep =0;
        var seed = 1;
        function $(id) { return document.getElementById(id); }
        function random() {
            if ($("ndr").checked) {
                return Math.random();
            } else {
                var x = Math.sin(seed) * 10000; seed += 1; return x - Math.floor(x);
            }
        }
        function updateseed() { $("_seed").value = $("seed").value; }
        function update_seed() { var val = parseInt($("_seed").value); if (!isNaN(val)) { $("seed").value = val; } updateseed(); }
        function uniform(min, max) { var ran = random(); return min + ran * (max - min); }
        function rbool() { return random() > 0.5; }
        function Shuffle(arr) {
            for (var i = arr.length - 1; i > 0; i--) {
                var j = Math.floor(random() * (i + 1)); //random index
                [arr[i], arr[j]] = [arr[j], arr[i]]; // swap
            }
        }

        function plotpath(path, scale) {
            var len = path.getTotalLength();
            var ancestor = path.ownerSVGElement;
            let cp = [];
            let uinc = 0.0078125;
            for (let u = 0; u <= 1; u += uinc) {
                let p = path.getPointAtLength(u * len);
                p.rx = p.x / scale;
                p.ry = p.y / scale;
                p.x = Math.round(p.x / scale);
                p.y = Math.round(p.y / scale);
                p.u = u;
                p.path = path;
                if (cp.length && (Math.abs(cp[cp.length - 1].x - p.x) > 1 || Math.abs(cp[cp.length - 1].y - p.y) > 1)) {
                    //Lacking raster resolution
                    u -= uinc;
                    uinc = uinc / 2;
                    //console.log("uinc " + uinc);
                    if (uinc < 0.0000152587890625) {
                        uinc = 0.0078125;
                        cp.push(p);
                    }
                } else {
                    cp.push(p);
                }

            }
            return cp;
        }

        class Automata {
            constructor(rows, columns) {
                this.rows = rows;
                this.columns = columns;
                this.max_growth_dist = 0;
                let Array2D = (row, col) => [...Array(row)].map(x => Array(col).fill(0));
                this.grid = Array2D(rows, columns);
                //this.edgegrid = Array2D(rows, columns);
                this.seedpoints = [];
                this.colorArray = [];
                this.cornertable = [];
                this.cornergrid = Array2D(rows, columns);
                this.maskgrid = Array2D(rows, columns);
                this.borderdistgrid = Array2D(rows, columns);
                this.lockedgrid = Array2D(rows, columns);
            }

            fillmask(paths, scale) {
                const crosslookup = [[-1, 0], [1, 0], [0, 1], [0, -1]];

                var allpts = []
                var minx, miny, maxx, maxy
                for (let p of paths) {
                    var pts = plotpath(p, scale);
                    pts.forEach((pt) => {
                        allpts.push(pt);
                        if (isNaN(minx) || pt.x < minx) minx = pt.x;
                        if (isNaN(miny) || pt.y < miny) miny = pt.y;
                        if (isNaN(maxx) || pt.x > maxx) maxx = pt.x;
                        if (isNaN(maxy) || pt.y > maxy) maxy = pt.y;
                    });

                }
                // console.log("V", minx, maxx, miny, maxy);
                allpts.forEach((p) => {
                    // console.log(this.borderdistgrid.length, this.borderdistgrid[0].length,p.x,p.y)
                    this.borderdistgrid[p.y][p.x] = { rx: p.rx + 0.5, ry: p.ry + 0.5 };
                    this.maskgrid[p.y][p.x] = 1;

                });

                var regnum = 3;

                var grown;
                do {
                    var outside = true;
                    grown = false;
                    for (var i = -1; i < this.rows + 1; i++) {
                        for (var j = -1; j < this.columns + 1; j++) {
                            if (i < 0 || j < 0 || i > this.rows - 1 || j > this.columns - 1 || (this.maskgrid[i][j] > 1 && this.maskgrid[i][j] < regnum)) {
                                var togrow = [{ r: i, c: j }];
                                do {
                                    var p = togrow.pop();
                                    crosslookup.forEach((c) => {
                                        var ii = p.r + c[0];
                                        var jj = p.c + c[1];
                                        if (ii >= 0 && jj >= 0 && ii < this.rows && jj < this.columns) {

                                            if (!this.maskgrid[ii][jj]) {
                                                togrow.push({ r: ii, c: jj });
                                            }
                                            if (this.maskgrid[ii][jj] < 2) {
                                                if (p.r > 0 && p.c > 0 && p.r < this.rows && p.c < this.columns) {
                                                    if (this.maskgrid[p.r][p.c] > 1 && this.maskgrid[p.r][p.c] < regnum && this.maskgrid[p.r][p.c] % 2) {
                                                        this.outside = false;
                                                    }
                                                } else {
                                                    this.outside = true;
                                                }
                                                this.maskgrid[ii][jj] = regnum;
                                                grown = true;
                                            }
                                        }
                                    });
                                } while (togrow.length);

                            }
                        }

                    }
                    regnum += outside ? 1 : 2;
                } while (grown)

                for (var i = 0; i < this.rows; i++) {
                    for (var j = 0; j < this.columns; j++) {
                        this.maskgrid[i][j] = this.maskgrid[i][j] % 2;
                    }
                }
                allpts.forEach((p) => {
                    this.maskgrid[p.y][p.x] = 1;
                });
            }
            gridseed(gsize, randlen) {
                this.seedpoints = []
                var val = 1;
                for (var i = gsize / 2; i <= this.rows - gsize / 2; i += gsize) {
                    for (var j = gsize / 2; j <= this.columns - gsize / 2; j += gsize) {
                        var row = Math.floor(i + uniform(-(gsize / 2) * randlen, (gsize / 2) * randlen)) % this.rows;
                        var col = Math.floor(j + uniform(-(gsize / 2) * randlen, (gsize / 2) * randlen)) % this.columns;
                        if (row < 0) row += this.rows;
                        if (col < 0) col += this.columns;

                        if (!this.maskgrid[row][col]) {
                            this.grid[row][col] = val;
                            this.seedpoints.push({ row: row, col: col, val: val });
                            val = val + 1;
                        }

                    }
                }
                $("piececount").innerHTML = val - 1;
            }

            step(context, prefill) {
                var growth = []
                var growthdistchanged = (this.max_growth_dist != parseInt($("gradius").value));
                var ii = Math.floor(uniform(0, this.rows));
                var ij = Math.floor(uniform(0, this.columns));
                var fi = ii + this.rows;
                var fj = ij + this.columns;
                var reverse = rbool() && !prefill;
                if (growthdistchanged) {
                    for (var i = 0; i < this.rows; i++) {
                        for (var j = 0; j < this.columns; j++) {
                            this.lockedgrid[i][j] = 0;
                        }
                    }
                }
                this.max_growth_dist = parseInt($("gradius").value);
                if (prefill) {
                    ii = 0;
                    ij = 0;
                    fi = this.rows;
                    fj = this.columns;
                }
                if (reverse) {
                    for (var i = fi - 1; i >= ii; i--) {
                        for (var j = fj - 1; j >= ij; j--) {
                            var ti = i % this.rows;
                            var tj = j % this.columns;
                            if (this.grid[ti][tj] > 0 && !this.lockedgrid[ti][tj]) {
                                this.grow(ti, tj, growth, context, prefill);
                            }
                        }
                    }
                } else {
                    for (var i = ii; i < fi; i++) {
                        for (var j = ij; j < fj; j++) {
                            var ti = i % this.rows;
                            var tj = j % this.columns;
                            if (this.grid[ti][tj] > 0 && !this.lockedgrid[ti][tj]) {
                                this.grow(ti, tj, growth, context, prefill);
                            }
                        }
                    }
                }
                growth.forEach((grow) => {
                    this.grid[grow.row][grow.col] = grow.val;
                    var neigh = this.neighbor_coords(grow.row, grow.col, false).c;
                    neigh.forEach((n) => {
                        this.lockedgrid[n.row][n.col] = 0;
                    });
                });
                // if (!prefill) {
                //     this.edgefind(context);
                // }
                return growth.length
            }

            mindistandclosestpoint2path(corner) {

                var neighbor_coords = this.neighbor_coords(corner.row, corner.col, false).c;
                neighbor_coords.push(corner);
                let mind = 1e12
                let cp = null;
                let d = 0;
                neighbor_coords.forEach((nc) => {
                    let bg = this.borderdistgrid[nc.row][nc.col];
                    if (bg) {
                        // var len = bg.path.getTotalLength();
                        // for (let u = bg.u - 0.01; u <= bg.u + 0.01; u += 0.005) {
                        //     let p = bg.path.getPointAtLength(u * len);
                        d = Math.hypot(bg.rx - corner.col, bg.ry - corner.row)
                        if (d < mind) {
                            mind = d;
                            cp = { x: bg.rx, y: bg.ry };
                        }
                        // }
                    }
                });

                return { d: mind, cp: cp };
            }


            neighbor_coords(row, col, calc_weights) {
                var coords = [];
                var weight = 0;
                for (var i = -1; i < 2; i++) {
                    for (var j = -1; j < 2; j++) {
                        var pr = row + i;
                        var pc = col + j;
                        if ((i || j) && pr >= 0 && pc >= 0 && pr < this.rows && pc < this.columns) {
                            coords.push({ row: pr, col: pc });
                            if (calc_weights && (Math.abs(this.grid[pr][pc]) == Math.abs(this.grid[row][col]))) {
                                var w = i + j * 3 + 4;
                                w = w > 4 ? w - 1 : w;
                                weight += (1 << w);
                            }
                        }
                    }
                }
                return { c: coords, w: weight };
            }

            findcorners(customborder) {
                const lookup = [[[1, 1], [0, 1], [1, 0]], [[-1, -1], [0, -1], [-1, 0]], [[1, -1], [0, -1], [1, 0]], [[-1, 1], [0, 1], [-1, 0]]];
                var corners = [];
                let Array2D = (row, col) => [...Array(row)].map(x => Array(col).fill(0));
                this.cornergrid = Array2D(this.rows + 1, this.columns + 1);
                for (var i = -1; i < this.rows + 1; i++) {
                    for (var j = -1; j < this.columns + 1; j++) {
                        var corner_cand = [];

                        lookup.forEach((le) => {
                            if (i < 0 || j < 0 || j >= this.columns || i >= this.rows) {
                                var distinct = [0];
                            } else {
                                var distinct = [this.grid[i][j]];

                            }
                            le.forEach((c) => {
                                var ii = i + c[0];
                                var jj = j + c[1];
                                if (ii < 0 || jj < 0 || ii >= this.rows || jj >= this.columns) {
                                    if (!distinct.includes(0)) {
                                        distinct.push(0);
                                    }
                                } else {
                                    var val = this.grid[ii][jj];
                                    if (!distinct.includes(val)) {
                                        distinct.push(val);
                                    }
                                }
                            });
                            if (distinct.length > 2) {
                                var c = le[0];
                                var cr = c[0] > 0 ? c[0] : 0;
                                var cc = c[1] > 0 ? c[1] : 0;
                                var onborder = distinct.includes(0);
                                corner_cand.push({ row: i + cr, col: j + cc, onborder: onborder });
                            }
                        });

                        if (corner_cand.length == 1 && !this.cornergrid[corner_cand[0].row][corner_cand[0].col]) {
                            this.cornergrid[corner_cand[0].row][corner_cand[0].col] = 1;
                            corners.push(corner_cand[0]);
                        }
                    }
                }
                this.cornertable = [];
                if (customborder.paths) {
                    corners.forEach((c) => {
                        if (c.onborder) {
                            var mind = 2e9;
                            var newp = { x: c.col, y: c.row };
                            for (let p of customborder.paths) {
                                var dcp = this.mindistandclosestpoint2path(c);
                                if (dcp && dcp.d < mind) {
                                    mind = dcp.d;
                                    newp = dcp.cp;
                                }
                            }
                            this.cornertable.push({ row: c.row, col: c.col, x: newp.x, y: newp.y });
                        }
                    });
                }
                return corners;
            }
            grow(row, col, growth, context, prefill) {

                var neigh_coord = this.neighbor_coords(row, col, false).c;
                var grown = [];
                var currentcellval = this.grid[row][col]
                var seed = this.seedpoints.find((sp) => sp.val == currentcellval);

                var sc_neigh = 0;
                var sc_neigh_in_corner = 0;
                var other_color = 0;
                neigh_coord.forEach((neighbor) => {
                    if (this.grid[neighbor.row][neighbor.col]) {
                        if (Math.abs(this.grid[neighbor.row][neighbor.col]) == currentcellval) {
                            sc_neigh++;
                            if (neighbor.row != row && neighbor.col != col) {
                                sc_neigh_in_corner++;
                            }
                        } else {
                            other_color = Math.abs(this.grid[neighbor.row][neighbor.col]);
                        }
                    }
                });
                if (sc_neigh == neigh_coord.length) {
                    this.lockedgrid[row][col] = 1;
                } else {
                    if (!prefill && sc_neigh < 3) {
                        //Cell dies immediately if it's alone (2 neighbors of the same color or less) We don't want it to grow
                        //This avoids issues with spurious growth
                        if (sc_neigh_in_corner == sc_neigh && !this.maskgrid[row][col]) {
                            this.grid[row][col] = -other_color;
                            growth.push({ row: row, col: col, val: other_color });
                        }
                    } else if (prefill || random() < parseFloat($("growth_prob").value)) {

                        //We have enough neighbors, explore them
                        neigh_coord.forEach((neighbor) => {
                            var neighborval = this.grid[neighbor.row][neighbor.col];

                            if (!this.maskgrid[neighbor.row][neighbor.col] && (prefill || ((Math.abs(currentcellval) != Math.abs(neighborval)) && (neighbor.row == row || neighbor.col == col)))) {
                                var dist2seed = Math.sqrt((neighbor.row - seed.row) ** 2 + (neighbor.col - seed.col) ** 2);

                                if (prefill || (dist2seed < this.max_growth_dist)) {
                                    //We're close enough to the seed point, lets try to grow

                                    if (!neighborval) { //neighbor is empty
                                        //Just eat it
                                        growth.push({ row: neighbor.row, col: neighbor.col, val: currentcellval });
                                        grown.push({ row: neighbor.row, col: neighbor.col });
                                    } else if (!prefill && neighborval > 0) { //neighbor is taken by other piece
                                        //see if we can kill it and overtake
                                        var nnc_cw = this.neighbor_coords(neighbor.row, neighbor.col, true);
                                        if (lut[nnc_cw.w]) {
                                            var nnc = nnc_cw.c

                                            //get neighbor's neighbors of the same color;
                                            nnc = nnc.filter(nn => (Math.abs(this.grid[nn.row][nn.col]) == neighborval));
                                            var nnc_len = nnc.length;
                                            if ($("ppg").checked || nnc_len < 6) {
                                                var nnnc_len = 0;
                                                nnc.forEach((n) => {
                                                    var nnnc = this.neighbor_coords(n.row, n.col).c;
                                                    nnnc = nnnc.filter(nn => (Math.abs(this.grid[nn.row][nn.col]) == neighborval));
                                                    nnnc_len += nnnc.length;
                                                });


                                                //I don't know how the 6.2 thing works, but it seems to work. This algorithm was empirically found
                                                if (nnnc_len / nnc_len > parseFloat($("mnumber").value)) {
                                                    //console.log(nnnc_len + " " + nnc_len + " " + neighborval);
                                                    growth.push({ row: neighbor.row, col: neighbor.col, val: currentcellval });
                                                    grown.push({ row: neighbor.row, col: neighbor.col });
                                                }
                                            }
                                        }
                                    }

                                }
                            }
                        });
                        // if (!prefill && grown.length == 0) {
                        //    // this.lockedgrid[row][col] = 1;
                        // }
                    }

                    //TODO: If your only growth is a corner, don't grow DONE
                    if (grown.length == 1 && grown[0].row != row && grown[0].col != col) {
                        grown = [];
                        growth.pop();
                    }
                    grown.forEach((grow) => {
                        this.grid[grow.row][grow.col] = -this.grid[row][col];
                    });
                }
            }
            paintcorners(context, corners, size) {
                var pixelsize = parseInt($("pixelscell").value);
                corners.forEach((c) => {
                    context.fillStyle = "black";
                    context.fillRect((c.col * pixelsize) - size / 2, (c.row * pixelsize) - size / 2, size, size);
                });
            }
            findedgestep(edge, row, col, pdir, corner, context) {
                var pixelsize = parseInt($("pixelscell").value);
                if (row < 0 || col < 0 || row >= this.rows || col >= this.columns) {
                    return;
                }
                if (!corner && this.cornergrid[row][col] == 1) {
                    return;
                }
                if (pdir.includes("E")) {
                    //move east
                    var ii = row - 1;
                    var jj = col;
                    var v1 = this.grid[row][col];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row][col + 1] < 2) {
                            if (!this.cornergrid[row][col + 1])
                                this.cornergrid[row][col + 1] = 2;
                            edge.push({ row: row, col: col + 1 });
                            context.strokeStyle = "black";
                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo((col + 1) * pixelsize, (row) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row, col + 1, "NSE", false, context);
                        }
                        return; //only one movement!

                    }

                }
                if (pdir.includes("W")) {
                    //move west
                    var ii = row - 1;
                    var jj = col - 1;
                    var v1 = (col - 1) < 0 ? 0 : this.grid[row][col - 1];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row][col - 1] < 2) {
                            if (!this.cornergrid[row][col - 1])
                                this.cornergrid[row][col - 1] = 2;
                            edge.push({ row: row, col: col - 1 });
                            context.strokeStyle = "black";
                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo((col - 1) * pixelsize, (row) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row, col - 1, "NSW", false, context);
                        }
                        return; //only one movement!

                    }

                }
                if (pdir.includes("N")) {
                    //move north
                    var ii = row - 1;
                    var jj = col - 1;
                    var v1 = (row - 1) < 0 ? 0 : this.grid[row - 1][col];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row - 1][col] < 2) {
                            if (!this.cornergrid[row - 1][col])
                                this.cornergrid[row - 1][col] = 2;
                            edge.push({ row: row - 1, col: col });
                            context.strokeStyle = "black";
                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo(col * pixelsize, (row - 1) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row - 1, col, "NEW", false, context);
                        }
                        return; //only one movement!

                    }

                }
                if (pdir.includes("S")) {
                    //move south
                    var ii = row;
                    var jj = col - 1;
                    var v1 = this.grid[row][col];
                    var v2 = (ii < 0 || jj < 0) ? 0 : this.grid[ii][jj];
                    if (v1 && v2 && (v1 != v2)) {
                        if (this.cornergrid[row + 1][col] < 2) {
                            if (!this.cornergrid[row + 1][col])
                                this.cornergrid[row + 1][col] = 2;
                            edge.push({ row: row + 1, col: col });
                            context.strokeStyle = "black";

                            context.beginPath();
                            context.moveTo(col * pixelsize, row * pixelsize);
                            context.lineTo(col * pixelsize, (row + 1) * pixelsize);
                            context.stroke();
                            this.findedgestep(edge, row + 1, col, "SEW", false, context);
                        }
                        return; //only one movement!
                    }

                }

            }
            findedges(corners, context) {
                var edgepaths = [];
                var shortedgepaths = [];
                const directions = ["N", "S", "E", "W"];
                var pixelsize = parseInt($("pixelscell").value);
                corners.forEach((c) => {

                    // var size = 8;
                    // context.fillStyle = c.customborder ? "red" : "blue";
                    // context.fillRect((c.col * pixelsize) - size / 2, (c.row * pixelsize) - size / 2, size, size);
                    // if (!c.customborder) {
                    directions.forEach((d) => {
                        var edge = [c];
                        this.findedgestep(edge, c.row, c.col, d, true, context);

                        if (edge.length > 1) {
                            if (edge.length == 2) {
                                var sameedge = shortedgepaths.filter(sep => (
                                    (sep[0].row == edge[0].row && sep[0].col == edge[0].col && sep[1].row == edge[1].row && sep[1].col == edge[1].col) ||
                                    (sep[1].row == edge[0].row && sep[1].col == edge[0].col && sep[0].row == edge[1].row && sep[0].col == edge[1].col)
                                ));
                                if (!sameedge.length) {
                                    edgepaths.push(edge);
                                    shortedgepaths.push(edge);
                                }
                            } else {
                                edgepaths.push(edge);
                            }
                        }
                        //.log("Edged");
                    });
                    // }
                });
                return edgepaths;
            }
            paint(context, palette) {
                var pixelsize = parseInt($("pixelscell").value);
                context.clearRect(0, 0, $("automata").width, $("automata").height);
                context.font = "12px Arial";
                context.textAlign = "center";

                for (var i = 0; i < this.rows; i++) {
                    for (var j = 0; j < this.columns; j++) {

                        if (this.grid[i][j] < 0) {
                            console.log("WTF");
                        }

                        if (this.grid[i][j]) {
                            context.fillStyle = this.colorArray[Math.abs(this.grid[i][j] - 1) % this.colorArray.length];
                            context.fillRect(j * pixelsize, i * pixelsize, pixelsize, pixelsize);

                        }
                    }
                }
            }

            paintmask(context, paths) {
                var pixelsize = parseInt($("pixelscell").value);
                context.clearRect(0, 0, $("automata").width, $("automata").height);
                context.font = "12px Arial";
                context.textAlign = "center";

                for (var i = 0; i < this.rows; i++) {
                    for (var j = 0; j < this.columns; j++) {

                        if (this.maskgrid[i][j] < 0) {
                            console.log("WTF");
                        }

                        if (this.maskgrid[i][j] % 2) {
                            context.fillStyle = "red";

                        } else {
                            context.fillStyle = "blue";
                        }

                        context.fillRect(j * pixelsize, i * pixelsize, pixelsize, pixelsize);



                    }
                }
                for (let p of paths) {
                    var p2d = new Path2D(p.getAttribute("d"));
                    context.stroke(p2d);
                }
            }
        }
        var canvas;
        var automata;
        var palette;
        var svgstr;
        var svgstrsave;
        var context;
        var customborder = {};
        // save function pieced together from here: https://stackoverflow.com/questions/19327749/javascript-blob-filename-without-link
        function save(filename, data) {
            var blob = new Blob([data], { type: "image/svg+xml" });
            if (window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveBlob(blob, filename);
            }
            else {
                var elem = window.document.createElement('a');
                elem.href = window.URL.createObjectURL(blob);
                elem.download = filename;
                document.body.appendChild(elem);
                elem.click();
                document.body.removeChild(elem);
            }
        }

        function savesvg() {
            save("jigsaw.svg", svgstrsave);
        }

        function generate() {
            update_seed();
            seed = parseInt($("_seed").value);
            var pixelsize = parseInt($("pixelscell").value);
            var rows = parseInt($("nrows").value);
            var cols = parseInt($("ncols").value);
            var gsize = parseInt($("gsize").value);
            var gnoise = parseFloat($("gnoise").value);
            var cell_scale = parseFloat($("cell_scale").value)

            if (customborder.svgdata) {
                while ($("svgcontainer").firstChild) {
                    $("svgcontainer").removeChild($("svgcontainer").firstChild);
                }

                var svgdata = document.body.appendChild(customborder.svgdata);
                //Initial flattening to get rid of transforms
                flatten(svgdata, false, true);

                var paths_svg = svgdata.getElementsByTagName("path");
                var pgroup = document.createElementNS($("svgcontainer").namespaceURI, "g");
                //When all transforms have been applied for all paths, the remaining one is the viewbox/viewport thing
                var vt = paths_svg[0].getCTM();
                $("svgcontainer").append(pgroup);

                for (let p of paths_svg) {
                    var newpath = document.createElementNS($("svgcontainer").namespaceURI, "path")
                    newpath.setAttribute("d", p.getAttribute('d'));
                    newpath.setAttribute("stroke", "black");
                    newpath.setAttribute("stroke-width", 1);
                    newpath.setAttribute("fill", "none");
                    pgroup.appendChild(newpath);
                }

                document.body.removeChild(svgdata);
                //De-viewboxfy
                pgroup.setAttribute("transform", "matrix(" + vt.a + "," + vt.b + "," + vt.c + "," + vt.d + "," + vt.e + "," + vt.f + ")");
                flatten($("svgcontainer"), false, true);
                //Scale
                pgroup.setAttribute("transform", "scale(" + parseFloat($("cbsf").value) + ")");
                flatten($("svgcontainer"), false, true);
                //To left corner
                pgroup.setAttribute("transform", "translate(" + (-($("svgcontainer").getBBox().x)) + "," + (-($("svgcontainer").getBBox().y)) + ")");
                flatten($("svgcontainer"), false, true);
                //Now the customborder is normalized

                customborder.width = ($("svgcontainer").getBBox().width + $("svgcontainer").getBBox().x);// * pixelsize;
                customborder.height = ($("svgcontainer").getBBox().height + $("svgcontainer").getBBox().y);// * pixelsize;

                customborder.paths = pgroup.getElementsByTagName("path");

                cols = Math.ceil(customborder.width / cell_scale) + 1;
                rows = Math.ceil(customborder.height / cell_scale) + 1;

            }

            if (rows * cols > 1e6) {
                var extra_text = "\nHint: Try reducing the number of rows and columns until rows times columns is less than 1 million.\n";
                if (customborder.svgdata) {
                    var max_scale = parseFloat($("cbsf").value) / Math.sqrt((rows * cols) / 1e6);
                    extra_text = "\nHint: Try reducing the custom border scale factor. The maximum value recommended for your custom border is " + max_scale.toFixed(2) + ".\n";
                }
                var confirmed = window.confirm("You are going to generate a " + Math.round(rows) + " x " + Math.round(cols) + " cell jigsaw. This is very large, and " +
                    "it may take a very long time to generate or even lock your browser. Just close it if this happens." + extra_text + "Do you want to continue generating the jigsaw?");
                if (!confirmed) {
                    return;
                }
            }

            automata = new Automata(rows, cols);

            if (customborder.paths) {
                automata.fillmask(customborder.paths, cell_scale);
                pgroup.setAttribute("transform", "translate(" + (cell_scale / 2) + "," + (cell_scale / 2) + ")");
                flatten($("svgcontainer"), false, true);
            }



            canvas = $("automata");
            canvas.setAttribute("width", cols * pixelsize + 5);
            canvas.setAttribute("height", rows * pixelsize + 5);// * 2);


            if (canvas.getContext) {
                context = canvas.getContext('2d');


                // if (customborder.paths) {
                //     automata.paintmask(context,customborder.paths);
                // }
                automata.gridseed(gsize, gnoise);
                palette = ImageTracer.generatepalette(automata.seedpoints.length + 1);
                Shuffle(palette);
                palette.forEach((c) => {
                    automata.colorArray.push("#" + c.r.toString(16).toUpperCase().padStart(2, "0") + c.g.toString(16).toUpperCase().padStart(2, "0") + c.b.toString(16).toUpperCase().padStart(2, "0"));
                });

                automata.paint(context, palette);
                var growncells = 0;
                do {
                    growncells = automata.step(context, true);
                    //automata.paint(context);
                } while (growncells);
                paintoutput();
            }
            updatedimensions(1);
            growthstep=0;
            $("grs").innerHTML = growthstep;
        }

        function paintoutput() {
            var rows = automata.rows;
            var cols = automata.columns;
            var pixelsize = parseInt($("pixelscell").value);
            var cellscale = parseFloat($("cell_scale").value);
            canvas = $("automata");
            canvas.setAttribute("width", cols * pixelsize + 5);
            canvas.setAttribute("height", rows * pixelsize + 5);// * 2);
            $("svgcontainer").setAttribute("width", cols * cellscale);
            $("svgcontainer").setAttribute("height", rows * cellscale);
            automata.paint(context, palette);
            // console.log("Painted");
            var corners = automata.findcorners(customborder);
            // console.log("Cornered");

            var edges = automata.findedges(corners, context);
            // console.log("Edged");

            var paths = [];
            //convert to how svgtracejs wants this
            edges.forEach((e) => {
                var path = {};
                path.points = [];
                path.boundingbox = [];
                path.holechildren = [];
                path.isholepath = false;
                for (var i = 0; i < e.length; i++) {
                    var p = e[i];

                    // if(path.points.length){
                    //     var lp = path.points[path.points.length-1];
                    //     var deltax = (p.col -lp.x)/50;
                    //     var deltay = (p.row -lp.y)/50;
                    //     for (var i =1; i<50;i++){
                    //         path.points.push({ x: lp.x + i*deltax, y: lp.y+i*deltay });
                    //         //console.log({ x: lp.x + i*deltax, y: lp.y+i*deltay })
                    //     }
                    // }
                    if ($("cps").checked && i > 0 && i < e.length - 1) {
                        var d1 = [e[i].col - e[i - 1].col, e[i].row - e[i - 1].row];
                        var d2 = [e[i + 1].col - e[i].col, e[i + 1].row - e[i].row];
                        if ((d1[0] + d2[0]) != 0 && (d1[1] + d2[1]) != 0) {
                            var plast = path.points[path.points.length - 1];
                            var p1n = { x: e[i - 1].col + d1[0] / 2, y: e[i - 1].row + d1[1] / 2 };
                            var p2n = { x: e[i].col + d2[0] / 2, y: e[i].row + d2[1] / 2 };
                            if (!(p1n.x == plast.x && p1n.y == plast.y)) {
                                path.points.push(p1n);
                            } else if ($("scp").checked) {
                                var pplast = path.points[path.points.length - 2];
                                if (pplast.x == p2n.x || pplast.y == p2n.y) {
                                    path.points.pop();
                                }
                            }
                            path.points.push(p2n);
                        } else {
                            path.points.push({ x: p.col, y: p.row });
                        }
                    } else {
                        path.points.push({ x: p.col, y: p.row });

                        if ($("scp").checked && i < e.length - 3) {
                            var d1 = [e[i + 1].col - e[i].col, e[i + 1].row - e[i].row];
                            var d2 = [e[i + 3].col - e[i + 2].col, e[i + 3].row - e[i + 2].row];
                            var csum = Math.abs(d1[0] + d2[0]) + Math.abs(d1[1] + d2[1]);
                            if (!csum) {
                                path.points.push({ x: p.col + d1[0] / 2, y: p.row + d1[1] / 2 });
                                path.points.push({ x: e[i + 3].col - d2[0] / 2, y: e[i + 3].row - d2[1] / 2 });
                                i = i + 2;
                            }
                        }
                    }
                }

                paths.push(path);

            });
            var options = { pal: palette, scale: cellscale, ltres: parseFloat($("ltres").value), qtres: parseFloat($("qtres").value), strokewidth: .5, linefilter: false, rightangleenhance: false, layering: 0, layercontainerid: "layercnt" };

            // Getting ImageData from canvas with the helper function getImgdata().
            [svgstr, svgstrsave] = ImageTracer.pathsToSVG(paths, customborder, automata.cornertable, automata.columns, automata.rows, options);
            // console.log("SVG'd");

            // Synchronous tracing to SVG string
            //var svgstr = ImageTracer.gridToSVG(automata.grid, palette, options);
            while ($("svgcontainer").firstChild) {
                $("svgcontainer").removeChild($("svgcontainer").firstChild);
            }
            // Appending SVG
            ImageTracer.appendSVGString(svgstr, 'svgcontainer');

            if ($("stv").checked) {
                var parser = new DOMParser();
                xmldoc = parser.parseFromString(svgstr, "image/svg+xml");
                var svgjig = xmldoc.getElementsByTagName("svg")[0];
                var outpaths = svgjig.getElementsByTagName("path");
                context.strokeStyle = "black";
                context.lineWidth = 2*(cellscale/pixelsize);
                context.scale((pixelsize / cellscale), (pixelsize / cellscale))
                for (let p of outpaths) {
                    var p2d = new Path2D(p.getAttribute("d"));
                    context.stroke(p2d);
                }
            }
            updatedimensions();
        }



        function growstep() {
            growncells = automata.step(context, false);
            // console.log("Grown");
            growthstep++;
            $("grs").innerHTML = growthstep;
            paintoutput();

        }
        function stopautogrow() {
            if (autogrowth) {
                toggleautogrow();
            }
        }
        function toggleautogrow() {
            if (automata) {
                autogrowth = !autogrowth;
                if (autogrowth) {
                    timerID = setTimeout(function () {
                        growstep();
                        timerID = setTimeout(arguments.callee, 1)
                    }, 1);
                    $("autogrow").innerHTML = "Stop Automatic Growth";
                } else {
                    clearTimeout(timerID);
                    $("autogrow").innerHTML = "Start Automatic Growth";
                }
            }
        }

        function unloadborder() {
            customborder = {};
            updatedimensions();
        }
        function updatedimensions(gen) {
            var width_mm = 0;
            var height_mm = 0;
            if (customborder.svgdata) {
                if (customborder.width) {
                    width_mm = (customborder.width);
                    height_mm = (customborder.height);
                } else {
                    $("dimensions").innerHTML = "Generate to know";
                    return;
                }

            } else {
                width_mm = parseInt($("ncols").value) * parseFloat($("cell_scale").value);
                height_mm = parseInt($("nrows").value) * parseFloat($("cell_scale").value);
            }
            $("dimensions").innerHTML = Math.round(width_mm) + " x " + Math.round(height_mm);
        }

        function loadborder() {
            var borderfile = $("borderfile");
            var fr = new FileReader();
            fr.readAsText(borderfile.files[0]);
            fr.onload = function () {
                //console.log(fr.result);
                var parser = new DOMParser();
                xmldoc = parser.parseFromString(fr.result, "image/svg+xml");
                var svgdata_p = xmldoc.getElementsByTagName("svg")[0];
                customborder.svgdata = svgdata_p;
                updatedimensions();
            };
        }
        function switchtab(evt, tab) {
            // Declare all variables
            var i, j, tabcontent, tablinks;
            stopautogrow()

            if (tab == "rect") {
                unloadborder();
            } else {

                tabcontent = document.getElementsByClassName("controltable");
                for (i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].removeAttribute("style");
                }
                // Get all elements with class="tabcontent" and hide them
                tabcontent = document.getElementsByClassName("controltable");
                for (i = 0; i < tabcontent.length; i++) {
                    rowelems = tabcontent[i].rows;
                    for (j = 0; j < rowelems.length; j++) {
                        if (!rowelems[j].className || rowelems[j].className == tab) {
                            rowelems[j].removeAttribute("style")
                        } else {
                            rowelems[j].style.display = "none"
                        }
                    }
                }

            }
            // Get all elements with class="tablinks" and remove the class "active"
            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }

            // Show the current tab, and add an "active" class to the button that opened the tab
            // document.getElementById(tab).style.display = "block";
            evt.currentTarget.className += " active";

            if (tab == "custom" && !customborder.width) {
                window.alert("Please choose a custom SVG border file");
                document.getElementById("borderfile").click();
            }
        }


    </script>
</head>

<body onload="$('seed').value = random() * 10000; updateseed();">
</br>
</br>
  <strong>Lex Altern Puzzle</strong>
</br>
</br>
    <div class="tab">
        <button class="tablinks" id="default" onclick="switchtab(event, 'custom')">Custom SVG border</button>
        <button class="tablinks" onclick="switchtab(event, 'rect')">Rectangular border</button>

    </div>
    <div class="tabcontent">
        <table class="controltable">
            <tr class="custom">
                <td>SVG border file:</td>
                <td><input type="file" id="borderfile" accept=".svg" onchange="loadborder()"></td>
            </tr>
            <tr class="custom">
                <td>Custom border scale factor:</td>
                <td><input id="cbsf" onchange="updatedimensions(0)" type="text" value="0.2" size="5" /></td>
            </tr>
            <tr class="rect">
                <td>Columns:</td>
                <td><input id="ncols" onchange="updatedimensions(0)" type="text" value="100" size="5" /> cells</td>
            </tr>
            <tr class="rect">
                <td>Rows:</td>
                <td><input id="nrows" onchange="updatedimensions(0)" type="text" value="100" size="5" /> cells</td>
            </tr>
            <tr>
                <td>Seed:</td>
                <td><input id="_seed" type="text" value="0" onchange="update_seed()" /></td>
                <td><input id="seed" type="range" value="0" min="0" max="9999" step="1" onchange="updateseed()" /></td>
            </tr>
            <tr>
                <td>Use non-deterministic randomness:</td>
                <td><input id="ndr" type="checkbox" />(seed is ignored if ticked)</td>
            </tr>
            <tr>
                <td>Grid size:</td>
                <td><input id="gsize" type="text" value="25" size="5" /> cells</td>
            </tr>
            <tr>
                <td>Initial Grid position noise (0 to 1):</td>
                <td><input id="gnoise" type="text" value="0.9" size="5" /></td>
            </tr>
            <tr>
                <td>Growth radius:</td>
                <td><input id="gradius" type="text" value="20" size="5" /> cells</td>
            </tr>
            <tr>
                <td>Curve fitting threshold (>0, decimal):</td>
                <td><input id="qtres" type="text" value="1" size="5" /></td>
            </tr>
            <tr>
                <td>Straight line fitting threshold (>0, decimal):</td>
                <td><input id="ltres" type="text" value="0.00001" size="5" /></td>
            </tr>
            <tr>
                <td>Smooth choke points:</td>
                <td><input id="scp" type="checkbox" /></td>
            </tr>
            <tr>
                <td>Corner pre-smooth:</td>
                <td><input id="cps" type="checkbox" /></td>
            </tr>
            <tr>
                <td>"Pointy" piece growth:</td>
                <td><input id="ppg" type="checkbox" /></td>
            </tr>
            <tr>
                <td>Show traced vectors over preview</td>
                <td><input id="stv" type="checkbox" /></td>
            </tr>
            <tr>
                <td>Magic number(just leave it at 6.2):</td>
                <td><input id="mnumber" type="text" value="6.2" size="5" /></td>
            </tr>
            <tr>
                <td>Growth probability (0 to 1):</td>
                <td><input id="growth_prob" type="text" value="0.5" size="5" /></td>
            </tr>
            <tr>
                <td>Actual cell size:</td>
                <td><input id="cell_scale" onchange="updatedimensions(0)" type="text" value="2" size="5" /> mm</td>
            </tr>
            <tr>
                <td>Cell preview scale:</td>
                <td><input id="pixelscell" type="text" value="2" size="5" /> pixels/cell</td>
            </tr>
            <!-- <tr class="custom">
                <td><button onclick="loadborder()">Load custom border</button></td>
                <td><button onclick="unloadborder()">Unload custom border</button></td>
            </tr> -->
            <tr>
                <td><button onclick="generate()">Generate Jigsaw</button></td>
            </tr>
            <tr>
                <td><button onclick="growstep()">Grow Jigsaw Manually</button></td>
                <td><button id="autogrow" onclick="toggleautogrow()">Start Automatic Growth</button></td>
            </tr>
            <tr>
                <td><button onclick="savesvg()">Download SVG (non-overlapping vectors)</button></td>
            </tr>
            <tr>
                <td>This jigsaw has: <label id="piececount">0</label> pieces</td>
            </tr>
            <tr>
                <td>Jigsaw dimensions: <label id="dimensions">200 x 200</label> mm</td>
            </tr>
            <tr>
                <td>Growth step: <label id="grs">0</label></td>
            </tr>
        </table>

    </div>


    <script>
        document.getElementById("default").click();
    </script>
    <svg id="svgcontainer"></svg>
    <canvas id="automata"></canvas>
    <div id="layercnt"></div>

</body>

</html>
